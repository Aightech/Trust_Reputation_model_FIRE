breed [ consumers consumer ]

consumers-own
[
  activity;;alpha
]

to init-consumer 
  set color blue
  set activity random-float (max-activity-consumers - min-activity-consumers) + min-activity-consumers 
  set rating-history n-values history-size [[0 0 0]]
  set history-index 0
  random-position
  
end

to  process-consumer
  if random-float 1.0 < activity ;; determine if the consumer ask for a service or not
  [
    let nearest-providers min-n-of 10 providers [2 * asin((distance myself) / 2) * pi / 180];; TODO 10 ?
    let nearest-providers-id [who] of nearest-providers
    let p 0 ;; id of the provider we will ask a service
    ifelse trust-interaction-model or trust-witness-model or trust-certified-model 
    [ set p choose(nearest-providers-id) ]
    [ set p one-of nearest-providers-id ]
    let utility 0
    ask turtle p [ 
      set utility performance-provider(2 * asin((distance myself) / 2) * pi / 180)
      store-rating-provider p utility ticks
      set list-UG lput utility list-UG
    ]
    store-rating-consumer p utility ticks
  ]
end

to-report choose [ nearest-providers-id ]
  ;print "- choose"
  let T-max -1
  let id-max -1
  let res 0
  let T_k 0
  let rho_k 0
  let denominator_T 0
  let numerator_T 0
  
  let T 0
  
  let T-to-find 0
  let Tfound 0
  let nb-T 0
  let T-moy 0
  let has-no-trust-value-list []
  
  foreach nearest-providers-id
  [ p ->
    ;print " ----"
    set denominator_T 0
    set numerator_T 0
    if trust-interaction-model ;interaction
    [
      ;print "IT"
      set T-to-find T-to-find + 1
      set res trust-interaction(p)
      set T_k item 0 res
      ;print T_k
      ifelse T_k = -2 [set T_k 0][set Tfound Tfound + 1]
      set rho_k item 1 res   
      ;print rho_k     
      set numerator_T numerator_T + wI * T_k * rho_k 
      set denominator_T denominator_T + ( wI * rho_k ) 
    ]
    if trust-witness-model ;witness
    [
      set T-to-find T-to-find + 1
      set res trust-witness(p)
      set T_k item 0 res
      ifelse T_k = -2 [set T_k 0][set Tfound Tfound + 1]
      set rho_k item 1 res          
      set numerator_T numerator_T + wW * T_k * rho_k  
      set denominator_T denominator_T + ( wW * rho_k )   
    ]
    if trust-certified-model ;certified 
    [
      set T-to-find T-to-find + 1
      set res trust-certified(p)
      set T_k item 0 res
      ifelse T_k = -2 [set T_k 0][set Tfound Tfound + 1]
      set rho_k item 1 res         
      set numerator_T numerator_T + wC * T_k * rho_k 
      set denominator_T denominator_T + ( wC * rho_k )
    ]    
    ;print "T"
    ;print Tfound
    ifelse Tfound > 0 ;; if at least one value has been calculated
    [ 
      ifelse denominator_T != 0 
      [ set T numerator_T / denominator_T ][set T 0]  ;; TODO: add weights
      set T-moy T-moy + T 
      set nb-T nb-T + 1
      
      ;print T
      if T >= T-max 
      [
        set T-max T
        set id-max p
      ]
    ]
    [
      set has-no-trust-value-list lput p has-no-trust-value-list
    ]
  ]  
  
  let proba 0
  ifelse nb-T > 0
  [
    set T-moy T-moy / nb-T
    set proba exp(T-max / Temp) / (exp(T-max / Temp) + exp(T-moy / Temp))
    let rand random-float 1
    ifelse rand > proba and not empty? has-no-trust-value-list        
    [ ;print "exploration"
      report one-of has-no-trust-value-list ] ;;
    [ ;print "exploitation"
      ;print id-max
      report id-max ]
  ]
  [report one-of has-no-trust-value-list ]
end

to-report trust-interaction [ p ]
  let list-of-review review-of(p)
  report compute-Tk(list-of-review)
end

to-report trust-witness [ p ]
  ;;let list-of-review tree-consumers-review p 5 []
  let list-of-review tree-consumers-review2 p nRL
  report compute-Tk(list-of-review)
end

to-report trust-certified [ p ]
  let list-of-review []
  ;print p
  ask turtle p [    
    set list-of-review rating-history
    ;print rating-history
  ]
  report compute-Tk(list-of-review)
end

to-report tree-consumers-review [ p i close-list]
  let list-of-review review-of(p)
  ifelse empty? list-of-review 
  [ 
    let close-consumers (consumers with [2 * asin((distance myself) / 2) * pi / 180 < radius-of-operation and (position who close-list) = false ])
    ask close-consumers 
    [
      set list-of-review sentence list-of-review tree-consumers-review p (i - 1) []
    ]
    report  []
  ]
  [ report list-of-review ]
end

to-report tree-consumers-review2 [ p n ]
  let consumers-acquaintances acquaintances with [breed = consumers] ;; extract consumers from acquaintances
  let n-cons min list nBF count consumers-acquaintances  
  let query-list min-n-of n-cons consumers-acquaintances [2 * asin((distance myself) / 2) * pi / 180] ;; extact nBF closest consumers
  let list-of-ratings [] ;; list with all the ratings of provider p
  let temp-list-of-ratings [] ;; temp list to save ratings of one specific consumer regarding a provider
  ask query-list
  [
    set temp-list-of-ratings review-of p    
    ifelse empty? temp-list-of-ratings AND n > 0
    [
      set list-of-ratings sentence tree-consumers-review2 p (n - 1) list-of-ratings
    ]
    [
      set list-of-ratings sentence temp-list-of-ratings list-of-ratings
    ]
  ]
  report list-of-ratings  
end

to-report compute-Tk [ list-of-rating ]
  ;;#########################
  ;;compute TK with the list L not empty and return TK
  let w 0
  let sum_w 0
  let Tk 0
  let denominator 0
  let rating-reliability 0
  let deviation-reliability 0
  ifelse empty? list-of-rating
  [ report (list -2 0) ]
  [
    ;print "list"
    ;print list-of-rating
    foreach list-of-rating
    [
      n -> 
      set w exp(-(ticks - item 2 n) / lambda)
      set Tk (Tk + w * (item 1 n))
      set sum_w (sum_w + w)
    ]
    set Tk Tk / sum_w
    ;print "rr"
    set rating-reliability (1 - exp( - gamma * sum_w))
    ;print rating-reliability
    foreach list-of-rating
    [
      n -> 
      set w exp(-(ticks - item 2 n) / lambda)
      set deviation-reliability deviation-reliability + w * (abs( item 1 n - Tk)) 
    ]
    ;print "dr"
    set deviation-reliability 1 - 0.5 * deviation-reliability / sum_w
    ;print deviation-reliability
    report (list Tk (rating-reliability * deviation-reliability))
  ]
  ;;#########################
end

to-report review-of [ b ]
  ;;#########################
  ;;if ask list of transaction with agent b  >> to-report average [a b]report (a + b) / 2
  let list-of-rating []
  foreach rating-history
  [
    n -> 
    if empty? n != true and (item 0 n) = b
    [
        set list-of-rating lput n list-of-rating
    ]
  ]
  report list-of-rating
  ;;#########################
end

to store-rating-consumer [ id v t ]
  ;;#########################"
  ;;at the end of a deal
  set rating-history replace-item history-index rating-history [0 0 0];; init the rating slot.
  set rating-history (replace-item history-index rating-history
                  (replace-item 0 (item history-index rating-history) id));;set the id of the selected provider
  set rating-history (replace-item history-index rating-history
                  (replace-item 1 (item history-index rating-history) (v / 10)));;set the UG of the deal
  set rating-history (replace-item history-index rating-history
                  (replace-item 2 (item history-index rating-history) t));;set the time of the deal

  ifelse history-index < history-size - 1 [ set history-index history-index + 1 ] [ set history-index 0 ] ;;inc the index of the history of rating
  ;;#########################"
end