breed [ consumers consumer ]

consumers-own
[
  activity;;alpha
]

to init-consumer
  set color blue
  set activity random-float (max-activity-consumers - min-activity-consumers) + min-activity-consumers 
  set rating-history n-values history-size [[0 0 0]]
  set history-index 0
  random-position
  
end

to  process-consumer
  if random-float 1.0 < activity ;; determine if the consumer ask for a service or not
  [
    ;;getProviders:list of 
    let nearest-providers min-n-of 10 providers [2 * asin((distance myself) / 2) * pi / 180];; TODO 10 ?
    let nearest-providers-id [who] of nearest-providers
    let p 0 ;; id of the provider we will ask a service
    ;print nearest-providers-id
    ifelse trust-interaction-model or trust-witness-model or trust-certified-model 
    [ set p choose(nearest-providers-id) ]
    [ set p one-of nearest-providers-id ]
    let utility 0    
    print p
    ask turtle p [ 
      set utility performance-provider(2 * asin((distance myself) / 2) * pi / 180)
      ;print "save ratings"
      ;print who
      store-rating-provider p utility ticks
    ]
    store-rating-consumer p utility ticks
    set mean-UG mean-UG + utility
  ]
end

to-report choose [ nearest-providers-id ]
  let T-max -1
  let id-max -1
  let Ti 0
  let Tw 0
  let Tc 0
  let Tfound 0
  let T-to-find 0
  let nb-T 0
  let T-moy 0
  let has-no-trust-value-list []
  
  foreach nearest-providers-id
  [ p ->
    if trust-interaction-model 
    [
      ;print "IT"
      set T-to-find T-to-find + 1
      set Ti trust-interaction(p)
      ifelse Ti = -2 [ set Ti 0 ][ set Tfound Tfound + 1]
      ;print Ti
    ]
    if trust-witness-model 
    [
      print "trust witness"
      set T-to-find T-to-find + 1
      set Tw trust-witness(p)
      ifelse Tw = -2 [ set Tw 0 ][ set Tfound Tfound + 1]
      
    ]
    if trust-certified-model 
    [
      set T-to-find T-to-find + 1
      set Tc trust-certified(p)
      ifelse Tc = -2 [ set Tc 0 ][ set Tfound Tfound + 1]
    ]
    
    ifelse Tfound > 0 ;; if at least one value has been calculated
    [ 
      ;print "T"
      ;print Ti
      ;print Tw
      ;print Tc
      let T Ti + Tw + Tc ;; TODO: add weights
      set T-moy T-moy + T 
      set nb-T nb-T + 1
      if T > T-max 
      [
        set T-max T
        set id-max p
      ]
    ]
    [
      set has-no-trust-value-list lput p has-no-trust-value-list
    ]
  ]
  let proba 0
  ifelse nb-T > 0
  [
    set T-moy T-moy / nb-T
    ;print "Tmax"
    ;print T-max
    set proba exp(T-max / Temp) / (exp(T-max / Temp) + exp(T-moy / Temp))
    let choice random-float 1
    ifelse proba < choice and not empty? has-no-trust-value-list        
    [ print "exploration"
      report one-of has-no-trust-value-list ] ;;
    [ print "exploitation"
      report id-max ] ;;exploitationexploration
  ]
  [ ;print "NO TRUST VALUE"
    report one-of has-no-trust-value-list ]
end

to-report trust-interaction [ p ]
  let list-of-review review-of(p)
  report compute-Tk(list-of-review)
end

to-report trust-witness [ p ]
  ;;let list-of-review tree-consumers-review p 5 []
  ;print "build tree"
  let list-of-review tree-consumers-review2 p nRL
  report compute-Tk(list-of-review)
end

to-report trust-certified [ p ]
  let list-of-review []
  ;print "---- review from provider"
  ;print p
  ask turtle p [    
    set list-of-review rating-history
  ]
  ;print list-of-review
  report compute-Tk(list-of-review)
end

to-report tree-consumers-review [ p i close-list]
  ;let close-providers (providers with [2 * asin((distance myself) / 2) * pi / 180 < radius-of-operation])
  ;let lp [who] of close-providers
  let list-of-review review-of(p)
  ifelse empty? list-of-review 
  [ 
    let close-consumers (consumers with [2 * asin((distance myself) / 2) * pi / 180 < radius-of-operation and (position who close-list) = false ])
    ;let lc [who] of close-consumers
    ask close-consumers 
    [
      set list-of-review sentence list-of-review tree-consumers-review p (i - 1) []
    ]
    report  []
  ]
  [ report list-of-review ]
  ;let close-provider [who] of n-of 2 (providers with [2 * asin((distance myself) / 2) * pi / 180 < radius-of-operation])
  ;print close-provider
  
   ;close-provider
end

to-report tree-consumers-review2 [ p n ]
  ;;print who
  ;;print n
  let consumers-acquaintances acquaintances with [breed = consumers] ;; extract consumers from acquaintances
  let n-cons min list nBF count consumers-acquaintances  
  let query-list min-n-of n-cons consumers-acquaintances [2 * asin((distance myself) / 2) * pi / 180] ;; extact nBF closest consumers
  let list-of-ratings [] ;; list with all the ratings of provider p
  let temp-list-of-ratings [] ;; temp list to save ratings of one specific consumer regarding a provider
  ask query-list
  [
    set temp-list-of-ratings review-of p    
    ifelse empty? temp-list-of-ratings AND n > 0
    [
      set list-of-ratings sentence tree-consumers-review2 p (n - 1) list-of-ratings
    ]
    [
      set list-of-ratings sentence temp-list-of-ratings list-of-ratings
    ]
  ]
  report list-of-ratings  
end

to-report compute-Tk [ list-of-rating ]
  ;;#########################
  ;;compute TK with the list L not empty and return TK
  let Tk 0
  let denominator 0
  ifelse empty? list-of-rating
  [ report -2 ]
  [
    let i 0
    foreach list-of-rating
    [
      n -> 
      set Tk (Tk + exp(-(ticks - item 2 n) / lambda) * (item 1 n))
      set denominator (denominator + exp(-(ticks - item 2 n) / lambda))
      set i i + 1
    ]
  report Tk / denominator
  ]
  ;print "Tk"
  ;print Tk
  ;print "D"
  ;print denominator
  ;;#########################
end

to-report review-of [ b ]
  ;;#########################
  ;;if ask list of transaction with agent b  >> to-report average [a b]report (a + b) / 2
  let list-of-rating []
  let i 0
  foreach rating-history
  [
    n -> 
    if empty? n != true and (item 0 n) = b
    [
        set list-of-rating lput n list-of-rating
    ]
    set i i + 1
  ]
  ;print "list-rating"
  ;print list-of-rating
  report list-of-rating
  ;;#########################
end

to store-rating-consumer [ id v t ]
  ;;#########################"
  ;;at the end of a deal
  ;let id 23
  ;let t 10
  ;let v 5
  print v / 10
  set rating-history replace-item history-index rating-history [0 0 0];; init the rating slot.
  set rating-history (replace-item history-index rating-history
                  (replace-item 0 (item history-index rating-history) id));;set the id of the selected provider
  set rating-history (replace-item history-index rating-history
                  (replace-item 1 (item history-index rating-history) (v / 10)));;set the UG of the deal
  set rating-history (replace-item history-index rating-history
                  (replace-item 2 (item history-index rating-history) t));;set the time of the deal

  ifelse history-index < history-size - 1 [ set history-index history-index + 1 ] [ set history-index 0 ] ;;inc the index of the history of rating
  ;;#########################"
end