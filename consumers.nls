breed [ consumers consumer ]

consumers-own
[
  activity;;alpha
]

to init-consumer
  set color blue
  set activity random-float (max-activity-consumers - min-activity-consumers) + min-activity-consumers 
  ;;set rating-history array:from-list n-values history-size [0]
  set rating-history n-values history-size [[0 0 0]]
  ;set trust-model? false
  random-position
  ;;init of each customer
  ;;let history-rating []
  ;;set history-index 0
  ;set history-rating n-values size-history [[23 2 0]]
  ;;print "history-rating"
  ;;print rating-history
  
end

to process-consumer
  if random-float 1.0 < activity ;; determine if the consumer ask for a service or not
  [
    print "activity"
    ;;getProviders:list of 
    ;let nearest-providers min-n-of 10 providers [distance myself];; TODO 10 ?
    let nearest-providers min-n-of 10 providers [2 * asin((distance myself) / 2) * pi / 180];; TODO 10 ?
    let nearest-providers-id [who] of nearest-providers
    let p 0 ;; id of the provider we will ask a service
    print nearest-providers-id
    ifelse trust-interaction-model or trust-witness-model or trust-certified-model 
    [ set p choose(nearest-providers-id) ]
    [ set p one-of nearest-providers-id ]
    let utility 0
    ask turtle p [ set utility performance-provider 2 * asin((distance myself) / 2) * pi / 180 ]
    store-rating p utility ticks
  ]
end

to-report choose [ nearest-providers-id ]
  print "choose"
  let T-max -1
  let Id-max -1
  let Ti 0
  let Tw 0
  let Tc 0
  let Tfound 0
  let T-to-find 0
  let nb-T 0
  let T-moy 0
  let has-no-trust-value-list []
  
  foreach nearest-providers-id
  [ p ->
    if trust-interaction-model 
    [
      set T-to-find T-to-find + 1
      set Ti trust-interaction(p)
      ifelse Ti = -2 [ set Ti 0 ][ set Tfound Tfound + 1]
    ]
    if trust-witness-model 
    [
      print "trust witness"
      set T-to-find T-to-find + 1
      set Tw trust-witness(p)
      ifelse Tw = -2 [ set Tw 0 ][ set Tfound Tfound + 1]
      
    ]
    if trust-certified-model 
    [
      set T-to-find T-to-find + 1
      set Tc trust-certified(p)
      ifelse Tc = -2 [ set Tc 0 ][ set Tfound Tfound + 1]
    ]
    
    ifelse Tfound > 0 ;; if at least one value has been calculated
    [ 
      let T Ti + Tw + Tc ;; TODO: add weights
      set T-moy T-moy + T 
      set nb-T nb-T + 1
      if T > T-max 
      [
        set T-max T
        set id-max p
      ]
    ]
    [
      set has-no-trust-value-list lput p has-no-trust-value-list
    ]
  ]
  let proba 0
  ifelse nb-T > 0
  [
    set T-moy T-moy / nb-T
    set proba exp(T-max / Temp) / (exp(T-max / Temp) + exp(T-moy / Temp))
    let choice random-float 1
    ifelse proba < choice and not empty? has-no-trust-value-list
    [ report one-of has-no-trust-value-list ] ;;exploration
    [ report id-max ] ;;exploitation
  ]
  [ report one-of has-no-trust-value-list ]
end

to-report trust-interaction [ p ]
  let list-of-review review-of(p)
  report compute-Tk(list-of-review)
end

to-report trust-witness [ p ]
  ;;let list-of-review tree-consumers-review p 5 []
  print "build tree"
  let list-of-review tree-consumers-review2 p nRL
  report compute-Tk(list-of-review)
end

to-report trust-certified [ p ]
  let list-of-review review-of(p)
  report compute-Tk(list-of-review)
end

to-report tree-consumers-review [ p i close-list]
  ;let close-providers (providers with [2 * asin((distance myself) / 2) * pi / 180 < radius-of-operation])
  ;let lp [who] of close-providers
  let list-of-review review-of(p)
  ifelse empty? list-of-review 
  [ 
    let close-consumers (consumers with [2 * asin((distance myself) / 2) * pi / 180 < radius-of-operation and (position who close-list) = false ])
    ;let lc [who] of close-consumers
    ask close-consumers 
    [
      set list-of-review sentence list-of-review tree-consumers-review p (i - 1) []
    ]
    report  []
  ]
  [ report list-of-review ]
  ;let close-provider [who] of n-of 2 (providers with [2 * asin((distance myself) / 2) * pi / 180 < radius-of-operation])
  ;print close-provider
  
   ;close-provider
end

to-report tree-consumers-review2 [ p n ]
  ;;print who
  ;;print n
  let consumers-acquaintances acquaintances with [breed = consumers] ;; extract consumers from acquaintances
  let n-cons min list nBF count consumers-acquaintances  
  let query-list min-n-of n-cons consumers-acquaintances [2 * asin((distance myself) / 2) * pi / 180] ;; extact nBF closest consumers
  let list-of-ratings [] ;; list with all the ratings of provider p
  let temp-list-of-ratings [] ;; temp list to save ratings of one specific consumer regarding a provider
  ask query-list
  [
    set temp-list-of-ratings review-of p    
    ifelse empty? temp-list-of-ratings AND n > 0
    [
      set list-of-ratings sentence tree-consumers-review2 p (n - 1) list-of-ratings
    ]
    [
      set list-of-ratings sentence temp-list-of-ratings list-of-ratings
    ]
  ]
  report list-of-ratings  
end

to-report compute-Tk [ list-of-rating ]
  ;;#########################
  ;;compute TK with the list L not empty and return TK
  let Tk 0
  let denominator 0
  ifelse empty? list-of-rating
  [ report -2 ]
  [
    let i 0
    foreach list-of-rating
    [
      n -> 
      set Tk Tk + exp(-(item 2 n) / lambda) * (item 1 n)
      set denominator denominator + exp(-(item 2 n) / 0.1)
      set i i + 1
    ]
  ]
  print "Tk"
  print Tk
  print "D"
  print denominator
  report Tk / denominator
  ;;#########################
end

to-report review-of [ b ]
  ;;#########################
  ;;if ask list of transaction with agent b  >> to-report average [a b]report (a + b) / 2
  let list-of-rating []
  let i 0
  foreach rating-history
  [
    n -> 
    if empty? n != true and (item 0 n) = b
    [
        set list-of-rating lput n list-of-rating
    ]
    set i i + 1
  ]
  ;print "list-rating"
  ;print list-of-rating
  report list-of-rating
  ;;#########################
end